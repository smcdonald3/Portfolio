# Encoding Text Files using Huffman Trees

## Course Project
CSC 2431, Spring 2020 (Instructor: Carlos Arias)

## Design
When the program is compiled and run, the program:
1. Opens the file for input and creates a Frequency table.
1. Sort the Frequency Table using the frequency.
1. Uses the Frequency Table to start creating the Huffman Tree from the bottom up.
1. Traverses the tree once created to create the code for each of the
symbols (character) found in the file. This results in a Encoding Table.
1. Reads the input file using the Encoding Table, and writes the encoding into the output file for each character.

Additionally, the program:
1. Has an option to decode the encoded file by storing the Huffman Tree in the encoded file.
1. Converts the binary string generated by the encoding phase into actual binary representation, resulting in a compressed file that is smaller than the original file.

## What is given?
You are given eight files:
- `test-file-0.txt` the first input file
- `test-file-0.table` the output to screen of the first input file
- `test-file-0.encoded` the output file of the first input file
- `test-file-1.txt` the second input file
- `test-file-1.table` the output to screen of the second input file
- `test-file-1.encoded` the output file of the second input file
- `test-file-2.txt` the third input file
- `test-file-2.table` the output to screen of the third input file
- `test-file-2.encoded` the output file of the third input file
- `test-file-3.txt` the fourth input file
- `test-file-3.table` the output to screen of the fourth input file
- `test-file-3.encoded` the output file of the fourth input file

## How the program is supposed to work

Ideally you should write a makefile, but you can compile the following way:
```
g++ yoursource1.cpp yoursource2.cpp -o huffman -std=c++11 -Wall
```
This will result in an executable name `huffman`, remember to specify the name of the exacutable in case you make your own `makefile`. The program should work with command line parameters the following way:
- `./huffman -encode inputfile outputfile`       
  - It will encode the file `inpufile` and create a file `outputfile` with the huffman encoding of the first file       
- `./huffman -decode inputfile outputfile`
  - It will decode the `inputfile` and write the decoded information into the `outputfile`

### Examples:
To encode a file named `mybook.txt` and put the encoding into a file named `myencodedbook.txt`:
```
./huffman -encode mybook.txt myencodedbook.txt
```

To decode a file named `coded.txt` and create a decoded file named `original.txt`:
```
./huffman -decode coded.txt original.txt
```

### Output to Screen
Your program should output the Coding Table in the screen using JSON-like format, as follows:
```
{key:   , code: 11}
{key:  a, code: 010}
{key:  e, code: 0010}
{key:  o, code: 0110}
{key:  u, code: 0111}
{key:  r, code: 1000}
{key:  n, code: 1010}
{key:  i, code: 1011}
{key:  l, code: 00001}
{key:  s, code: 00010}
{key:  d, code: 00110}
{key:  m, code: 10011}
{key:  p, code: 000000}
{key:  c, code: 000001}
{key: CR, code: 000110}
{key:  t, code: 000111}
{key:  g, code: 001111}
{key:  q, code: 100100}
{key:  b, code: 100101}
{key:  h, code: 0011100}
{key:  f, code: 00111010}
{key:  z, code: 00111011}
```
This is the output of the program when ran using `test-file-0.txt`. Things to notice:
- The file is sorted by encoding, shorter encodings first
- For certain characters, they are changed to be able to display:
  - CR for displaying charater `'\n'`
  - LF for displaying character `'\r'`

The encoded file (without extra challenge) will be a single line with 0 and 1 only.

## What is expected?
- Your code ***must*** compile.
- Your code ***must not*** compile with warnings.
- Your program ***must not*** crash.
- Your program is expected to implement a Tree Data Structure, there will be a code inspection to verify this.
- Every source file must contain header comments with the following format:
 ```
 /*
  Filename: huffmantree.h
  Description: Declaration of the class HuffmanTree to represent the binary Huffman Tree
  Author: McDonald Berger
  Date: 05/29/2019
  Course: Data Structures II
 */
 ```
- The program will be tested with the given files, and with additional files. Your grade will be calculated based on the screen output and file output. These outputs must be identical to the given outputs.
- Your code needs to show good programming practices: appropriate amount of
comments for your methods, indentation, meaningful
variable names, identifiers convention (CamelCase for functions, camelCase
for variables, _camelCase for data members, SNAKE_CASE for constants),
header comments, correct file names, etc. Failure to code appropriate will
result in strong points penalization.

## How to Test your Lab
Once you finished coding your lab you may want to test it to check it is correctly working. The steps would be:
1. Compile your program, make sure the executable name is `huffman`
1. Run the program using the first input file: `./huffman -enconde test-file-0.txt my-0.encoded > my.table`
1. Previous step will create files:
   1. `my-0.encoded` contains the encoded file `test-file-0.txt`
   1. `my-0.table` contains the output to screen that shows the Huffman Code Table
1. Compare the files, if there is no output, it means the files are identical and your program is working as expected.
   1. `diff test-file-0.encoded my-0.encoded` This will check if your encoded file is identical to the given file.
   1. `diff test-file-0.table my-0.table` This will check if your encoding table is identical to the given encoding table.

### If you are doing the extra credit
The comparison of the encoded files will fail, since you will have to save the Huffman Tree in the beginning of the file. So, you will need to follow this steps (Applies for Extra Challenge and for Extra - Extra Challenge).
1. Run the program to decode: `./huffman -decode my-0.encoded my-0.decoded`
1. The previous command will convert the encoded file into the original file
1. Compare the file with the original: `diff my-0.decoded test-file-0.txt` if there is no output, it means the files are identical and your program is working as expected.

NOTE: If you are using the Windows command line, you will need to use `fc` instead of `diff`.
